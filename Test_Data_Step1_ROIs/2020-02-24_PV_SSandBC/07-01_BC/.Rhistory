# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/03-01")
knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/02-01")
# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-12_ACC/06-01")
########################## Set initial values###############################
############################################################################
k <- 3 #number of clusters chosen by hand based on silhouette plot
SNRcutoff <- 5
ROI_diameter_cutoff <- 3
myslice <- "03-01"
mydate <- "07-11-2020"
dateSlice <- paste(mydate,myslice,sep=" ")
height = 80
width = 80
## note that plots are saved in same location as this file, not working directory
saveclusterplot <- 1 #1 = save, 0 = don't save
clusterplotheight <- 6
clusterplotwidth <- 6
saveallpotentialroisplot <- 0 #1 = save, 0 = don't save
allroiplotheight <- 5
allroiplotwidth <- 6.5
savepotentialroiscorrectsizeplot <- 0 #1 = save, 0 = don't save
nonoverlaproiplotheight <- 5
nonoverlaproiplotwidth <- 8
saveroisgoodsnrplot <- 0 #1 = save, 0 = don't save
roiplotheight <- 5
roiplotwidth <- 6.5
savefinalroisplot <- 0 #1 = save, 0 = don't save
finalroiplotheight <- 5
finalroiplotwidth <- 6.5
#################### Read in data and load libraries #######################
############################################################################
library(ggplot2)
library(dendextend)
library(plyr)
library(dplyr)
library(reshape2)
library(tidyr)
library(reticulate)
myclusterdata <- read.csv("EachPixel_Cluster.csv",check.names = FALSE)
myclustAvgGps_df_sc <- as.data.frame(myclusterdata$AvgGps)
myfiles <- read.csv("EachPixel_Data.csv",check.names = FALSE)
electrodepixels <- read.csv("electrodepixels.csv",header=FALSE)
electrodepixels <- electrodepixels+1 #photoZ starts counting with 0
############## Hierarchical clustering using chosen k ######################
############################################################################
dist_mat <- dist(myclustAvgGps_df_sc,method="euclidean")
hclust_avg <- hclust(dist_mat,method="average")
cut_avg <- cutree(hclust_avg,k=k)
avg_dend_obj <- as.dendrogram(hclust_avg)
avg_col_dend <- color_branches(avg_dend_obj,h=k)
myclusterdata_df_cl <- mutate(myclusterdata, cluster = cut_avg)
myfiles_df_cl <- data.frame(matrix(ncol=ncol(myfiles)+1,
nrow=nrow(myfiles)))
colnames(myfiles_df_cl) <- c(colnames(myfiles),"Cluster")
myfiles_df_cl[,1:ncol(myfiles)] <- myfiles[,1:ncol(myfiles)]
for (i in 1:nrow(myclusterdata_df_cl)) {
myclusterpixelid <- which(myfiles_df_cl$PixelID==myclusterdata_df_cl$PixelID[i])
myfiles_df_cl$Cluster[myclusterpixelid] <- myclusterdata_df_cl$cluster[i]
}
clusteraverages_all <- data.frame(matrix(nrow=k,ncol=2))
colnames(clusteraverages_all) <- c("Avg","SD")
rownames(clusteraverages_all) <- paste(rep("Clust"),1:k,sep="")
clusteraverages <- data.frame(matrix(ncol=2,nrow=k))
colnames(clusteraverages) <- c("k","StN_Avg")
clusteraverages$k <- seq(1:k)
for (i in 1:k) {
allcolmeans <- colMeans(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),])
myclustersd <- sd(as.matrix(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),4:6]))
clusteraverages$StN_Avg[i] <- allcolmeans[which(colnames(myfiles_df_cl)=="AvgGps")]
clusteraverages_all$Avg[i] <- clusteraverages$StN_Avg[i]
clusteraverages_all$SD[i] <- myclustersd
}
if (((min(which(clusteraverages$StN_Avg>SNRcutoff)))-1)>0) {
clustercutoff <- (which(clusteraverages$StN_Avg>SNRcutoff))-1
} else {
clustercutoff <- 0
}
######################### Plot clusters ####################################
############################################################################
ggplot(myfiles_df_cl,aes(x=X,y=Y)) +
geom_tile(aes(fill=myfiles_df_cl$Cluster),color="gray") +
labs(title=paste(dateSlice,"Clusters"), fill="SNR Avg +/- SD") +
theme(
axis.title.y = element_blank(),
axis.title.x = element_blank(),
# axis.ticks = element_blank(),
# axis.text = element_blank(),
panel.background = element_blank(),
plot.title = element_text(hjust=0.5),
legend.position = "none"
) +
guides(fill = guide_legend(keyheight = 0.9)) +
scale_y_reverse() +
scale_fill_gradientn(breaks=seq(1:k),
labels=c(paste(round(clusteraverages_all$Avg,3),"+/-",round(clusteraverages_all$SD,3))),
colors=rev(c("red1","yellow1","green1","dodgerblue1","navy"))
)
if (saveclusterplot==1) {
ggsave("clusterplot.jpg",height=clusterplotheight,width=clusterplotwidth)
}
# matrixplot <- function(matrix_to_plot, ptitle) {
#   longData<-melt(matrix_to_plot)
#   longData<-longData[!is.na(longData$value),]
#   ggplot(longData, aes(x = Var2, y = Var1)) +
#     geom_tile(aes(fill=value)) +
#     scale_fill_gradient(low="blue", high="red") +
#     labs(x="x", y="y", title=ptitle) +
#     scale_y_reverse() +
#     theme_bw() + theme(axis.text.x=element_text(size=9, angle=0, vjust=0.3),
#                        axis.text.y=element_text(size=9),
#                        plot.title=element_text(size=11))
# }
############ Convert data to height x width representation #################
############################################################################
pixel_cluster_data <- t(matrix(myfiles_df_cl$Cluster, ncol=width, nrow=height))
pixel_cluster_data[is.na(pixel_cluster_data)] <- 0
pixel_cluster_data <- pixel_cluster_data[(height:1),]
pixel_sn_data <- t(matrix(myfiles_df_cl$Avg, ncol=width, nrow=height))
myfiles_df_cl_with_electrode <- mutate(myfiles_df_cl,Electrode = 0)
for (i in 1:nrow(electrodepixels)) {
myfiles_df_cl_with_electrode$Electrode[which(myfiles_df_cl_with_electrode$PixelID==electrodepixels[i,1])] <- 1
}
electrode_data <- t(matrix(myfiles_df_cl_with_electrode$Electrode, ncol=width, nrow=height))
electrode_x_min <- min(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_x <- max(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_min <- min(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_max <- max(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_y <- (electrode_y_min + electrode_y_max) / 2
py_config()
version()
r.version()
library(ggpubr)
library(pbkrtest)
library(NbClust)
help("install.packages")
update.packages("rENA")
library(rENA)
install.packages("rENA")
install.packages("rock")
install.packages("directedENA", repos = "cran.qe-libs.org”)
)
install.packages("directedENA",repos="cran.qe-libs.org")
install.packages("directedENA")
devtools::install_git(url='https://gitlab.com/epistemic-analytics/qe-packages/directedENA')
install.packages("installr")
library(installr)
updateR()
install.packages("directedENA",repos="cran.qe-libs.org")
devtools:install_git(url = "https://gitlab.com/epistemic-analytics/qe-packages/directedENA")
install.packages(devtools)
install.packages("devtools")
install.packages("directedENA",repos="cran.qe-libs.org")
devtools:install_git(url = "https://gitlab.com/epistemic-analytics/qe-packages/directedENA")
library(devtools)
devtools:install_git(url = "https://gitlab.com/epistemic-analytics/qe-packages/directedENA")
devtools::install_git(url = "https://gitlab.com/epistemic-analytics/qe-packages/directedENA")
install.packages("directedENA")
install.packages("directedENA",repos="cran.qe-libs.org")
devtools::install_git(url = "https://gitlab.com/epistemic-analytics/qe-packages/directedENA")
library(directedENA)
?directedENA
setwd("G:/My Drive/Jackson/Neuroplex_data/Analyzed_with_PhotoZ/Step1_ROIs/2020-02-24_PV_SSandBC/07-01_BC")
################# Set working directory and initial values #################
############################################################################
### click "session" -> "set working directory" -> "choose directory" OR
### control+shift+H, navigate to correct folder, copy working directory
### from console below to text in quotes
library(reticulate)
# py_install("collections")
# use_python("C:/Users/kates/AppData/Local/Programs/Python/Python38-82/python.exe")
knitr::knit_engines$set(python = reticulate::eng_python)
# knitr::opts_chunk$set(python.reticulate = FALSE)
# knitr::opts_knit$set(root.dir = "COPY WORKING DIRECTORY HERE")
knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/Neuroplex_data/Analyzed_with_PhotoZ/Step1_ROIs/2020-02-24_PV_SSandBC/07-01_BC")
k <-  3 #number of clusters chosen by hand based on silhouette plot
ROI_diameter_cutoff <- 3 #max number of pixels for diameter of ROI
myslice <- "03"
mydate <- "2020-02-24"
SNRcutoff <- 4
Ampcutoff <- 0.001
rois_per_dat_file <- 5 #60 makes it crash but 50 works
height = 80 #number of pixels in y axis
width = 80 #number of pixels in x axis
#################### Read in data and load libraries #######################
############################################################################
suppressMessages(suppressWarnings(library(ggplot2)))
suppressMessages(suppressWarnings(library(dendextend)))
suppressMessages(suppressWarnings(library(plyr)))
suppressMessages(suppressWarnings(library(dplyr)))
suppressMessages(suppressWarnings(library(reshape2)))
suppressMessages(suppressWarnings(library(tidyr)))
suppressMessages(suppressWarnings(library(reticulate)))
myclusterdata <- read.csv("EachPixel_Cluster.csv",check.names = FALSE)
myclustAvgGps_df_sc <- as.data.frame(myclusterdata$AvgGps)
myfiles <- read.csv("EachPixel_SNR_Data.csv",check.names = FALSE)
ampfiles <- read.csv("EachPixel_Amp_Data.csv",check.names = FALSE)
electrodepixels <- read.csv("electrodepixels.csv",header=FALSE)
electrodepixels <- electrodepixels+1 #photoZ starts counting with 0
############## Hierarchical clustering using chosen k ######################
############################################################################
dist_mat <- dist(myclustAvgGps_df_sc,method="euclidean")
hclust_avg <- hclust(dist_mat,method="average")
cut_avg <- cutree(hclust_avg,k=k)
avg_dend_obj <- as.dendrogram(hclust_avg)
avg_col_dend <- color_branches(avg_dend_obj,h=k)
myclusterdata_df_cl <- mutate(myclusterdata, cluster = cut_avg)
myfiles_df_cl <- data.frame(matrix(ncol=ncol(myfiles)+1,
nrow=nrow(myfiles)))
colnames(myfiles_df_cl) <- c(colnames(myfiles),"Cluster")
myfiles_df_cl[,1:ncol(myfiles)] <- myfiles[,1:ncol(myfiles)]
for (i in 1:nrow(myclusterdata_df_cl)) {
myclusterpixelid <- which(myfiles_df_cl$PixelID==myclusterdata_df_cl$PixelID[i])
myfiles_df_cl$Cluster[myclusterpixelid] <- myclusterdata_df_cl$cluster[i]
}
clusteraverages_all <- data.frame(matrix(nrow=k,ncol=2))
colnames(clusteraverages_all) <- c("Avg","SD")
rownames(clusteraverages_all) <- paste(rep("Clust"),1:k,sep="")
clusteraverages <- data.frame(matrix(ncol=2,nrow=k))
colnames(clusteraverages) <- c("k","StN_Avg")
clusteraverages$k <- seq(1:k)
for (i in 1:k) {
allcolmeans <- colMeans(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),])
myclustersd <- sd(as.matrix(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),4:6]))
clusteraverages$StN_Avg[i] <- allcolmeans[which(colnames(myfiles_df_cl)=="AvgGps")]
clusteraverages_all$Avg[i] <- clusteraverages$StN_Avg[i]
clusteraverages_all$SD[i] <- myclustersd
}
######################### Plot clusters ####################################
############################################################################
ggplot(myfiles_df_cl,aes(x=X,y=Y)) +
geom_tile(aes(fill=myfiles_df_cl$Cluster),color="gray") +
labs(title=paste("Step 2. Clusters"),subtitle=paste("Date: ",mydate,", Slice: ",myslice,", Clusters: ",k,sep=""), fill="SNR Avg +/- SD") +
theme(
axis.title.y = element_blank(),
axis.title.x = element_blank(),
panel.background = element_blank(),
plot.title = element_text(hjust=0.5),
plot.subtitle = element_text(hjust=0.5)
# legend.position = "none"
) +
guides(fill = guide_legend(keyheight = 0.9)) +
scale_y_reverse() +
scale_fill_gradientn(breaks=seq(1:k),
labels=c(paste(round(clusteraverages_all$Avg,3),"+/-",round(clusteraverages_all$SD,3))),
colors=rev(c("red1","yellow1","green1","dodgerblue1","navy"))
)
ggsave("Step2_Clusters.jpg",height=6,width=7.5)
############ Convert data to height x width representation #################
############################################################################
pixel_cluster_data <- t(matrix(myfiles_df_cl$Cluster, ncol=width, nrow=height))
pixel_cluster_data[is.na(pixel_cluster_data)] <- 0
pixel_sn_data <- t(matrix(myfiles_df_cl$Avg, ncol=width, nrow=height))
pixel_amp_data <- t(matrix(ampfiles$Avg, ncol=width, nrow=height))
myfiles_df_cl_with_electrode <- mutate(myfiles_df_cl,Electrode = 0)
for (i in 1:nrow(electrodepixels)) {
myfiles_df_cl_with_electrode$Electrode[which(myfiles_df_cl_with_electrode$PixelID==electrodepixels[i,1])] <- 1
}
electrode_data <- t(matrix(myfiles_df_cl_with_electrode$Electrode, ncol=width, nrow=height))
electrode_x_min <- min(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_x <- max(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_min <- min(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_max <- max(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_y <- (electrode_y_min + electrode_y_max) / 2
############### Save pixel coordinates of ROIs and electrode ###############
############################################################################
pixel_coords_for_all_rois <- py$pixel_coords_for_all_rois
total_pixels_in_all_rois <- py$total_pixels_in_all_rois
final_rois_from_python <- matrix(unlist(pixel_coords_for_all_rois),nrow = total_pixels_in_all_rois,byrow=TRUE)
final_rois <- data.frame(matrix(ncol=5,nrow=nrow(final_rois_from_python)))
colnames(final_rois) <- c("Pixel_ID","X","Y","ROI_ID","SNR")
final_rois$X <- final_rois_from_python[,1]+1
final_rois$Y <- final_rois_from_python[,2]+1
final_rois$SNR <- final_rois_from_python[,3]
for (i in 1:nrow(final_rois)) {
all_x <- which(myfiles_df_cl$X==final_rois$X[i])
all_y <- which(myfiles_df_cl$Y==final_rois$Y[i])
final_rois$Pixel_ID[i] <- intersect(all_x,all_y)
}
############## TEST BELOW ##################
roi_index <- 0
final_rois$ROI_ID[which(final_rois$SNR==k+1)] <- roi_index
roi_index <- 1
unique_SNR_no_electrode <- unique(final_rois$SNR)[-which(unique(final_rois$SNR)==k+1)]
for (i in 1:length(unique_SNR_no_electrode)) {
final_rois$ROI_ID[which(final_rois$SNR==unique_SNR_no_electrode[i])] <- roi_index
roi_index <- roi_index + 1
}
nROIs <- max(final_rois$ROI_ID)+1
dat_file_electrode <- data.frame(matrix(ncol=1,nrow=3*nROIs+1+nrow(final_rois)))
colnames(dat_file_electrode) <- NULL
dat_file_electrode[1,1] <- 1
row_id <- 2
dat_file_electrode[c(row_id,(row_id+2)),1] <- 0
# roi_index <- 0
# for (i in 1:length(unique(final_rois$SNR))) {
#   final_rois$ROI_ID[which(final_rois$SNR==unique(final_rois$SNR)[i])] <- roi_index
#   roi_index <- roi_index + 1
# }
#
# nROIs <- max(final_rois$ROI_ID)+1
# dat_file_electrode <- data.frame(matrix(ncol=1,nrow=3*nROIs+1+nrow(final_rois)))
# colnames(dat_file_electrode) <- NULL
# dat_file_electrode[1,1] <- 1
# row_id <- 2
# dat_file_electrode[c(row_id,(row_id+2)),1] <- 0
# dat_file_electrode[(row_id+1),1] <- length(which(final_rois$SNR==k+1))+1
dat_file_electrode[(row_id+1),1] <- length(which(final_rois$ROI_ID==0))+1
# dat_file_electrode[c((row_id+3):(row_id+2+length(which(final_rois$SNR==k+1)))),1] <- (final_rois$Pixel_ID[which(final_rois$SNR==k+1)])-1
dat_file_electrode[c((row_id+3):(row_id+2+length(which(final_rois$ROI_ID==0)))),1] <- (final_rois$Pixel_ID[which(final_rois$ROI_ID==0)])-1
write.table(dat_file_electrode,"electrode.dat",row.names = FALSE)
final_rois_no_electrode <- final_rois[-which(final_rois$ROI_ID==0),]
# final_rois_no_electrode <- final_rois[-which(final_rois$SNR==k+1),]
########### END TEST #########################
datfilebreakpoints <- c(seq(1,nROIs-1,by=rois_per_dat_file),nROIs)
for (i in 2:length(datfilebreakpoints)) {
if ((nROIs-1)%%rois_per_dat_file!=0 & i==length(datfilebreakpoints)) {
tracesinfile <- (nROIs-1)%%rois_per_dat_file # remainder so that if number ROIs not divisible by rois_per_dat_file, final dat file ends with final ROI
} else {
tracesinfile <- rois_per_dat_file
}
roiindexesinthisdatfile <- datfilebreakpoints[i-1]:(datfilebreakpoints[i]-1)
datfile <- data.frame(matrix(ncol=1,nrow=((tracesinfile*3+1)+length(unlist(final_rois_no_electrode$Pixel_ID[roiindexesinthisdatfile])))))
colnames(datfile) <- NULL
datfile[1,1] <- tracesinfile
rowindex <- 2
for (j in 1:tracesinfile) {
pixelidsinthisroi <- final_rois_no_electrode$Pixel_ID[which(final_rois_no_electrode$ROI_ID==roiindexesinthisdatfile[j])]
datfile[rowindex,1]  <- j-1
datfile[rowindex+1,1] <- length(pixelidsinthisroi)+1
datfile[rowindex+2,1]  <- j-1
datfile[(rowindex+3):(rowindex+3+length(pixelidsinthisroi)-1),1] <- pixelidsinthisroi-1
rowindex <- rowindex+3+length(pixelidsinthisroi)
write.table(datfile,
paste("ROIs",sprintf("%02d", min(roiindexesinthisdatfile)),"to",sprintf("%02d", max(roiindexesinthisdatfile)),".dat",sep=""),
row.names = FALSE)
}
}
################# Set working directory and initial values #################
############################################################################
### click "session" -> "set working directory" -> "choose directory" OR
### control+shift+H, navigate to correct folder, copy working directory
### from console below to text in quotes
library(reticulate)
# py_install("collections")
# use_python("C:/Users/kates/AppData/Local/Programs/Python/Python38-82/python.exe")
knitr::knit_engines$set(python = reticulate::eng_python)
# knitr::opts_chunk$set(python.reticulate = FALSE)
# knitr::opts_knit$set(root.dir = "COPY WORKING DIRECTORY HERE")
knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/Neuroplex_data/Analyzed_with_PhotoZ/Step1_ROIs/2020-02-24_PV_SSandBC/07-01_BC")
k <-  3 #number of clusters chosen by hand based on silhouette plot
ROI_diameter_cutoff <- 3 #max number of pixels for diameter of ROI
myslice <- "03"
mydate <- "2020-02-24"
SNRcutoff <- 4
Ampcutoff <- 0.001
rois_per_dat_file <- 50 #60 makes it crash but 50 works
height = 80 #number of pixels in y axis
width = 80 #number of pixels in x axis
#################### Read in data and load libraries #######################
############################################################################
suppressMessages(suppressWarnings(library(ggplot2)))
suppressMessages(suppressWarnings(library(dendextend)))
suppressMessages(suppressWarnings(library(plyr)))
suppressMessages(suppressWarnings(library(dplyr)))
suppressMessages(suppressWarnings(library(reshape2)))
suppressMessages(suppressWarnings(library(tidyr)))
suppressMessages(suppressWarnings(library(reticulate)))
myclusterdata <- read.csv("EachPixel_Cluster.csv",check.names = FALSE)
myclustAvgGps_df_sc <- as.data.frame(myclusterdata$AvgGps)
myfiles <- read.csv("EachPixel_SNR_Data.csv",check.names = FALSE)
ampfiles <- read.csv("EachPixel_Amp_Data.csv",check.names = FALSE)
electrodepixels <- read.csv("electrodepixels.csv",header=FALSE)
electrodepixels <- electrodepixels+1 #photoZ starts counting with 0
############## Hierarchical clustering using chosen k ######################
############################################################################
dist_mat <- dist(myclustAvgGps_df_sc,method="euclidean")
hclust_avg <- hclust(dist_mat,method="average")
cut_avg <- cutree(hclust_avg,k=k)
avg_dend_obj <- as.dendrogram(hclust_avg)
avg_col_dend <- color_branches(avg_dend_obj,h=k)
myclusterdata_df_cl <- mutate(myclusterdata, cluster = cut_avg)
myfiles_df_cl <- data.frame(matrix(ncol=ncol(myfiles)+1,
nrow=nrow(myfiles)))
colnames(myfiles_df_cl) <- c(colnames(myfiles),"Cluster")
myfiles_df_cl[,1:ncol(myfiles)] <- myfiles[,1:ncol(myfiles)]
for (i in 1:nrow(myclusterdata_df_cl)) {
myclusterpixelid <- which(myfiles_df_cl$PixelID==myclusterdata_df_cl$PixelID[i])
myfiles_df_cl$Cluster[myclusterpixelid] <- myclusterdata_df_cl$cluster[i]
}
clusteraverages_all <- data.frame(matrix(nrow=k,ncol=2))
colnames(clusteraverages_all) <- c("Avg","SD")
rownames(clusteraverages_all) <- paste(rep("Clust"),1:k,sep="")
clusteraverages <- data.frame(matrix(ncol=2,nrow=k))
colnames(clusteraverages) <- c("k","StN_Avg")
clusteraverages$k <- seq(1:k)
for (i in 1:k) {
allcolmeans <- colMeans(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),])
myclustersd <- sd(as.matrix(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),4:6]))
clusteraverages$StN_Avg[i] <- allcolmeans[which(colnames(myfiles_df_cl)=="AvgGps")]
clusteraverages_all$Avg[i] <- clusteraverages$StN_Avg[i]
clusteraverages_all$SD[i] <- myclustersd
}
######################### Plot clusters ####################################
############################################################################
ggplot(myfiles_df_cl,aes(x=X,y=Y)) +
geom_tile(aes(fill=myfiles_df_cl$Cluster),color="gray") +
labs(title=paste("Step 2. Clusters"),subtitle=paste("Date: ",mydate,", Slice: ",myslice,", Clusters: ",k,sep=""), fill="SNR Avg +/- SD") +
theme(
axis.title.y = element_blank(),
axis.title.x = element_blank(),
panel.background = element_blank(),
plot.title = element_text(hjust=0.5),
plot.subtitle = element_text(hjust=0.5)
# legend.position = "none"
) +
guides(fill = guide_legend(keyheight = 0.9)) +
scale_y_reverse() +
scale_fill_gradientn(breaks=seq(1:k),
labels=c(paste(round(clusteraverages_all$Avg,3),"+/-",round(clusteraverages_all$SD,3))),
colors=rev(c("red1","yellow1","green1","dodgerblue1","navy"))
)
ggsave("Step2_Clusters.jpg",height=6,width=7.5)
############ Convert data to height x width representation #################
############################################################################
pixel_cluster_data <- t(matrix(myfiles_df_cl$Cluster, ncol=width, nrow=height))
pixel_cluster_data[is.na(pixel_cluster_data)] <- 0
pixel_sn_data <- t(matrix(myfiles_df_cl$Avg, ncol=width, nrow=height))
pixel_amp_data <- t(matrix(ampfiles$Avg, ncol=width, nrow=height))
myfiles_df_cl_with_electrode <- mutate(myfiles_df_cl,Electrode = 0)
for (i in 1:nrow(electrodepixels)) {
myfiles_df_cl_with_electrode$Electrode[which(myfiles_df_cl_with_electrode$PixelID==electrodepixels[i,1])] <- 1
}
electrode_data <- t(matrix(myfiles_df_cl_with_electrode$Electrode, ncol=width, nrow=height))
electrode_x_min <- min(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_x <- max(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_min <- min(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_max <- max(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_y <- (electrode_y_min + electrode_y_max) / 2
############### Save pixel coordinates of ROIs and electrode ###############
############################################################################
pixel_coords_for_all_rois <- py$pixel_coords_for_all_rois
total_pixels_in_all_rois <- py$total_pixels_in_all_rois
final_rois_from_python <- matrix(unlist(pixel_coords_for_all_rois),nrow = total_pixels_in_all_rois,byrow=TRUE)
final_rois <- data.frame(matrix(ncol=5,nrow=nrow(final_rois_from_python)))
colnames(final_rois) <- c("Pixel_ID","X","Y","ROI_ID","SNR")
final_rois$X <- final_rois_from_python[,1]+1
final_rois$Y <- final_rois_from_python[,2]+1
final_rois$SNR <- final_rois_from_python[,3]
for (i in 1:nrow(final_rois)) {
all_x <- which(myfiles_df_cl$X==final_rois$X[i])
all_y <- which(myfiles_df_cl$Y==final_rois$Y[i])
final_rois$Pixel_ID[i] <- intersect(all_x,all_y)
}
############## TEST BELOW ##################
roi_index <- 0
final_rois$ROI_ID[which(final_rois$SNR==k+1)] <- roi_index
roi_index <- 1
unique_SNR_no_electrode <- unique(final_rois$SNR)[-which(unique(final_rois$SNR)==k+1)]
for (i in 1:length(unique_SNR_no_electrode)) {
final_rois$ROI_ID[which(final_rois$SNR==unique_SNR_no_electrode[i])] <- roi_index
roi_index <- roi_index + 1
}
nROIs <- max(final_rois$ROI_ID)+1
dat_file_electrode <- data.frame(matrix(ncol=1,nrow=3*nROIs+1+nrow(final_rois)))
colnames(dat_file_electrode) <- NULL
dat_file_electrode[1,1] <- 1
row_id <- 2
dat_file_electrode[c(row_id,(row_id+2)),1] <- 0
# roi_index <- 0
# for (i in 1:length(unique(final_rois$SNR))) {
#   final_rois$ROI_ID[which(final_rois$SNR==unique(final_rois$SNR)[i])] <- roi_index
#   roi_index <- roi_index + 1
# }
#
# nROIs <- max(final_rois$ROI_ID)+1
# dat_file_electrode <- data.frame(matrix(ncol=1,nrow=3*nROIs+1+nrow(final_rois)))
# colnames(dat_file_electrode) <- NULL
# dat_file_electrode[1,1] <- 1
# row_id <- 2
# dat_file_electrode[c(row_id,(row_id+2)),1] <- 0
# dat_file_electrode[(row_id+1),1] <- length(which(final_rois$SNR==k+1))+1
dat_file_electrode[(row_id+1),1] <- length(which(final_rois$ROI_ID==0))+1
# dat_file_electrode[c((row_id+3):(row_id+2+length(which(final_rois$SNR==k+1)))),1] <- (final_rois$Pixel_ID[which(final_rois$SNR==k+1)])-1
dat_file_electrode[c((row_id+3):(row_id+2+length(which(final_rois$ROI_ID==0)))),1] <- (final_rois$Pixel_ID[which(final_rois$ROI_ID==0)])-1
write.table(dat_file_electrode,"electrode.dat",row.names = FALSE)
final_rois_no_electrode <- final_rois[-which(final_rois$ROI_ID==0),]
# final_rois_no_electrode <- final_rois[-which(final_rois$SNR==k+1),]
########### END TEST #########################
datfilebreakpoints <- c(seq(1,nROIs-1,by=rois_per_dat_file),nROIs)
for (i in 2:length(datfilebreakpoints)) {
if ((nROIs-1)%%rois_per_dat_file!=0 & i==length(datfilebreakpoints)) {
tracesinfile <- (nROIs-1)%%rois_per_dat_file # remainder so that if number ROIs not divisible by rois_per_dat_file, final dat file ends with final ROI
} else {
tracesinfile <- rois_per_dat_file
}
roiindexesinthisdatfile <- datfilebreakpoints[i-1]:(datfilebreakpoints[i]-1)
datfile <- data.frame(matrix(ncol=1,nrow=((tracesinfile*3+1)+length(unlist(final_rois_no_electrode$Pixel_ID[roiindexesinthisdatfile])))))
colnames(datfile) <- NULL
datfile[1,1] <- tracesinfile
rowindex <- 2
for (j in 1:tracesinfile) {
pixelidsinthisroi <- final_rois_no_electrode$Pixel_ID[which(final_rois_no_electrode$ROI_ID==roiindexesinthisdatfile[j])]
datfile[rowindex,1]  <- j-1
datfile[rowindex+1,1] <- length(pixelidsinthisroi)+1
datfile[rowindex+2,1]  <- j-1
datfile[(rowindex+3):(rowindex+3+length(pixelidsinthisroi)-1),1] <- pixelidsinthisroi-1
rowindex <- rowindex+3+length(pixelidsinthisroi)
write.table(datfile,
paste("ROIs",sprintf("%02d", min(roiindexesinthisdatfile)),"to",sprintf("%02d", max(roiindexesinthisdatfile)),".dat",sep=""),
row.names = FALSE)
}
}
