
```{r setup, include = FALSE}
knitr::knit_engines$set(python = reticulate::eng_python)
# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/04-01")
knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/03-01")
# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/02-01")
# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-12_ACC/06-01")

# reticulate::repl_python() #to run python in r console
```

```{r fig.width=8, fig.height=8}

########################## Set initial values###############################
############################################################################

k <- 3 #number of clusters chosen by hand based on silhouette plot
SNRcutoff <- 5
ROI_diameter_cutoff <- 3
upside_down <- 0 #1 if upside-down, 0 if not

myslice <- "03-01"
mydate <- "07-11-2020"
dateSlice <- paste(mydate,myslice,sep=" ")
height = 80
width = 80

## note that plots are saved in same location as this file, not working directory
saveclusterplot <- 1 #1 = save, 0 = don't save
  clusterplotheight <- 6
  clusterplotwidth <- 6
saveallpotentialroisplot <- 0 #1 = save, 0 = don't save
  allroiplotheight <- 5
  allroiplotwidth <- 6.5
savepotentialroiscorrectsizeplot <- 0 #1 = save, 0 = don't save
  nonoverlaproiplotheight <- 5
  nonoverlaproiplotwidth <- 8
saveroisgoodsnrplot <- 0 #1 = save, 0 = don't save
  roiplotheight <- 5
  roiplotwidth <- 6.5
savefinalroisplot <- 0 #1 = save, 0 = don't save
  finalroiplotheight <- 5
  finalroiplotwidth <- 6.5

  
#################### Read in data and load libraries #######################
############################################################################

library(ggplot2)
library(dendextend)
library(plyr)
library(dplyr)
library(reshape2)
library(tidyr)
library(reticulate)

myclusterdata <- read.csv("EachPixel_Cluster.csv",check.names = FALSE)
myclustAvgGps_df_sc <- as.data.frame(myclusterdata$AvgGps)

myfiles <- read.csv("EachPixel_Data.csv",check.names = FALSE)

electrodepixels <- read.csv("electrodepixels.csv",header=FALSE)
electrodepixels <- electrodepixels+1 #photoZ starts counting with 0


############## Hierarchical clustering using chosen k ######################
############################################################################

dist_mat <- dist(myclustAvgGps_df_sc,method="euclidean")
hclust_avg <- hclust(dist_mat,method="average")
cut_avg <- cutree(hclust_avg,k=k)

avg_dend_obj <- as.dendrogram(hclust_avg)
avg_col_dend <- color_branches(avg_dend_obj,h=k)

myclusterdata_df_cl <- mutate(myclusterdata, cluster = cut_avg)

myfiles_df_cl <- data.frame(matrix(ncol=ncol(myfiles)+1,
                                   nrow=nrow(myfiles)))
colnames(myfiles_df_cl) <- c(colnames(myfiles),"Cluster")
myfiles_df_cl[,1:ncol(myfiles)] <- myfiles[,1:ncol(myfiles)]
for (i in 1:nrow(myclusterdata_df_cl)) {
  myclusterpixelid <- which(myfiles_df_cl$PixelID==myclusterdata_df_cl$PixelID[i])
  myfiles_df_cl$Cluster[myclusterpixelid] <- myclusterdata_df_cl$cluster[i]
}

clusteraverages_all <- data.frame(matrix(nrow=k,ncol=2))
colnames(clusteraverages_all) <- c("Avg","SD")
rownames(clusteraverages_all) <- paste(rep("Clust"),1:k,sep="")

clusteraverages <- data.frame(matrix(ncol=2,nrow=k))
colnames(clusteraverages) <- c("k","StN_Avg")
clusteraverages$k <- seq(1:k)
for (i in 1:k) {
  allcolmeans <- colMeans(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),])
  myclustersd <- sd(as.matrix(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),4:6]))
  clusteraverages$StN_Avg[i] <- allcolmeans[which(colnames(myfiles_df_cl)=="AvgGps")]
  clusteraverages_all$Avg[i] <- clusteraverages$StN_Avg[i]
  clusteraverages_all$SD[i] <- myclustersd
}

if (((min(which(clusteraverages$StN_Avg>SNRcutoff)))-1)>0) {
  clustercutoff <- (which(clusteraverages$StN_Avg>SNRcutoff))-1
} else {
  clustercutoff <- 0
}

######################### Plot clusters ####################################
############################################################################

ggplot(myfiles_df_cl,aes(x=X,y=Y)) +
  geom_tile(aes(fill=myfiles_df_cl$Cluster),color="gray") +
  labs(title=paste(dateSlice,"Clusters"), fill="SNR Avg +/- SD") +
  theme(
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    # axis.ticks = element_blank(),
    # axis.text = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(hjust=0.5),
    legend.position = "none"
  ) +
  guides(fill = guide_legend(keyheight = 0.9)) +
  # scale_y_reverse() +
  scale_fill_gradientn(breaks=seq(1:k),
                       labels=c(paste(round(clusteraverages_all$Avg,3),"+/-",round(clusteraverages_all$SD,3))),
                       colors=rev(c("red1","yellow1","green1","dodgerblue1","navy"))
  )

if (saveclusterplot==1) {
  ggsave("clusterplot.jpg",height=clusterplotheight,width=clusterplotwidth)
}

# matrixplot <- function(matrix_to_plot, ptitle) {
#   longData<-melt(matrix_to_plot)
#   longData<-longData[!is.na(longData$value),]
#   ggplot(longData, aes(x = Var2, y = Var1)) + 
#     geom_tile(aes(fill=value)) + 
#     scale_fill_gradient(low="blue", high="red") +
#     labs(x="x", y="y", title=ptitle) +
#     scale_y_reverse() +
#     theme_bw() + theme(axis.text.x=element_text(size=9, angle=0, vjust=0.3),
#                        axis.text.y=element_text(size=9),
#                        plot.title=element_text(size=11))
# }


############ Convert data to height x width representation #################
############################################################################
pixel_cluster_data <- t(matrix(myfiles_df_cl$Cluster, ncol=width, nrow=height))
pixel_cluster_data[is.na(pixel_cluster_data)] <- 0
# pixel_cluster_data <- pixel_cluster_data[(height:1),]

if (upside_down==0) {
  pixel_sn_data <- t(matrix(myfiles_df_cl$Avg, ncol=width, nrow=height))
} else {
  pixel_sn_data <- matrix(myfiles_df_cl$Avg, ncol=width, nrow=height)
}

myfiles_df_cl_with_electrode <- mutate(myfiles_df_cl,Electrode = 0)
for (i in 1:nrow(electrodepixels)) {
  myfiles_df_cl_with_electrode$Electrode[which(myfiles_df_cl_with_electrode$PixelID==electrodepixels[i,1])] <- 1
}
electrode_data <- t(matrix(myfiles_df_cl_with_electrode$Electrode, ncol=width, nrow=height))

electrode_x_min <- min(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_x <- max(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_min <- min(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_max <- max(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_y <- (electrode_y_min + electrode_y_max) / 2

```


```{python}

############ Identify each potential ROI and bounds for each ROI ###########
############################################################################

import numpy
import matplotlib.pyplot as plt
import pandas
pixel_cluster_data = r.pixel_cluster_data
width = len(pixel_cluster_data)
height = len(pixel_cluster_data[0])

plt.matshow(pixel_cluster_data)
plt.show()

cluster_results = numpy.zeros((width,height))

def combine_bound(bound1, bound2):
  if bound2 is None:
    return bound1
  if bound1 is None:
    return bound2
  result = [
    min(bound1[0],bound2[0]),
    max(bound1[1],bound2[1]),
    min(bound1[2],bound2[2]),
    max(bound1[3],bound2[3])
  ]
  return result

def check_cell(x, y, group_index, color):
  cell_value = pixel_cluster_data[y][x]
  # print ("cell value is",cell_value)
  if (cell_value != 0 and cluster_results[y][x] == 0 and (color == 0 or cell_value == color)):
    cluster_results[y][x] = group_index
    # print ("group_index is",group_index)
    my_bound = [x,x,y,y]
    xleft = max(0, x-1) #x coordinate of pixel to L
    xright = min(width-1, x+1) #x coordinate of pixel to R
    yup = max(0, y-1) #y coordinate of pixel down in number / up in direction"
    ydown = min(height-1, y+1) #y coordinate of pixel up in number / down in direction"
    # print ("cluster_results[y][x] is",cluster_results[y][x],"my_bound is",my_bound)
    # print ("xleft = ",xleft,"xright = ",xright,"yup = ",yup,"ydown = ",ydown)
    # # print ("yup")
    # child_bound = check_cell(x,yup,group_index,cell_value)
    # my_bound = combine_bound(my_bound,child_bound)
    # print ("ydown")
    child_bound = check_cell(x,ydown,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    # print ("yup")
    child_bound = check_cell(x,yup,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    # print ("xright")
    child_bound = check_cell(xright,y,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    # print ("xleft")
    child_bound = check_cell(xleft,y,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)

    # print ("my_bound is now",my_bound)
    return my_bound
  else:
    return None

group_index = 1 #0 = never visited, 1 = first roi, 2 = second roi, etc
group_bound = []


# check_cell(0,29,group_index,0)
# x = 0
# y = 29
# color = 0
# cell_value = pixel_cluster_data[y][x]
# print ("cell_value", cell_value)
# print ("cell_value != 0",cell_value != 0)
# print ("cluster_results[y][x] == 0",cluster_results[y][x] == 0)
# print ("color == 0 or cell_value == color",color == 0 or cell_value == color)
# cluster_results[y][x] = group_index
# print ("group_index",group_index)
# my_bound = [x,x,y,y]
# xleft = max(0, x-1) #x coordinate of pixel to L
# xright = min(width-1, x+1) #x coordinate of pixel to R
# yup = max(0, y-1) #y coordinate of pixel down in number / up in direction"
# ydown = min(height-1, y+1) #y coordinate of pixel up in number / down in direction"
# print ("cluster_results[y][x] is",cluster_results[y][x],"my_bound is",my_bound)
# print ("xleft = ",xleft,"xright = ",xright,"yup = ",yup,"ydown = ",ydown)


for i in range(0,width):
  for j in range(0,height):
    result = check_cell(i, j, group_index, 0)
    if result is not None:
      group_index += 1
      group_bound.append(result)

#print (group_bound)
#print (len(group_bound))
plt.matshow(cluster_results,vmin=0,vmax=19) #if dec vmax then better see some clusters
plt.show()
plt.matshow(cluster_results)
plt.show()
r.cluster_results = cluster_results
```

```{python}

############# Remove ROIs with diameter greater than cutoff ################
############################################################################

bound_limit = r.ROI_diameter_cutoff
# bound_limit = 3

for i in range(0,len(group_bound)):
  group = group_bound[i]
  x_big = (group[1] - group[0]) > (bound_limit-1)
  y_big = (group[3] - group[2]) > (bound_limit-1)
  if x_big or y_big:
    print (i,group,x_big,y_big,"is out of bounds.")
    cluster_results[cluster_results == (i+1)] = 0 #0 vs 1 index mismatch ie counting from 0 here but index from 1 above

r.cluster_results = cluster_results
plt.matshow(cluster_results)
plt.show()


```

```{python}

################ Separate remaining ROIs based on cluster ##################
############################################################################

pixel_cluster_data = pixel_cluster_data * (cluster_results > 0)

plt.matshow(pixel_cluster_data)
plt.show()
```

```{python}
############################ Add electrode #################################
############################################################################

electrode_data = r.electrode_data #1 if pixel in electrode, 0 if not
plt.matshow(electrode_data)
plt.show()

inverse_electrode_data = electrode_data
inverse_electrode_data = numpy.where(electrode_data==0, 1, inverse_electrode_data)
inverse_electrode_data = numpy.where(electrode_data==1, 0, inverse_electrode_data)
# inverse_electrode_data[electrode_data == 1] = 0
# inverse_electrode_data[electrode_data == 0] = 1
plt.matshow(inverse_electrode_data)
plt.show()
# print (electrode_data)

electrode_data = electrode_data * (max(numpy.unique(cluster_results))+1) #0 if not in electrode, 1+max group number if in cluster
# print (electrode_data)

plt.matshow(pixel_cluster_data)
plt.show()

electrode_cluster = max(numpy.unique(pixel_cluster_data))+1

# print (cluster_results[35][0])

pixel_cluster_data_with_electrode = pixel_cluster_data

for i in range(0,width): #add electrode as new "roi"
  for j in range(0,height):
    if electrode_data[j][i] != 0:
      cluster_results[j][i] = electrode_data[j][i]
      pixel_cluster_data_with_electrode[j][i] = electrode_cluster

# print (cluster_results[35][0])

plt.matshow(pixel_cluster_data)
plt.show()

```

``` {python}
electrode_x_min = r.electrode_x_min-1
electrode_x_max = r.electrode_tip_x-1
electrode_y_max = (height-1)-(r.electrode_y_min-1)
electrode_y_min = (height-1)-(r.electrode_y_max-1)
print (electrode_x_min,electrode_x_max,electrode_y_min,electrode_y_max)

plt.matshow(cluster_results)
plt.show()

plt.matshow(pixel_cluster_data)
plt.show()

numpy.max(cluster_results)
numpy.max(pixel_cluster_data)

rois_touching_electrode = []
for i in range(0,height):
  for j in range(0,width):
    cell_value = cluster_results[j][i]
    if cell_value!=0 and i>(electrode_x_min-2) and i<(electrode_x_max+2) and j>(electrode_y_min-2) and j<(electrode_y_max+2):
    # if cell_value!=0 and i>(electrode_x_min-1) and i<(electrode_x_max+1) and j>(electrode_y_min-1) and j<(electrode_y_max+1):
      rois_touching_electrode.append(cell_value)

rois_touching_electrode = numpy.unique(rois_touching_electrode)
print (rois_touching_electrode)

for i in range(0,width):
  for j in range(0,height):
    cell_value = cluster_results[j][i]
    if cell_value in rois_touching_electrode:
      cluster_results[j][i] = 0
      pixel_cluster_data[j][i] = 0

plt.matshow(cluster_results)
plt.show()

plt.matshow(pixel_cluster_data)
plt.show()


```

```{python}

##################### Remove ROIs that are touching ########################
############################################################################

plt.matshow(cluster_results)
plt.show()

plt.matshow(pixel_cluster_data)
plt.show()


visited_cells = numpy.zeros((width,height))
def check_collisions(x,y,group_index):
  cell_value = cluster_results[y][x]
  print ("cell_value",cell_value)
  # if cell_value != 0 and visited_cells[y][x] == 0 and cell_value!=max(numpy.unique(electrode_data)):
  if cell_value != 0 and visited_cells[y][x] == 0:
    visited_cells[y][x] = True
    if group_index == 0 or cell_value==group_index:
    # if (group_index == 0 or cell_value==group_index) and cell_value!=max(numpy.unique(electrode_data)):
    # if group_index == 0 or cell_value==group_index or cell_value==max(numpy.unique(electrode_data)):
      xleft = max(0, x-1)
      xright = min(width-1, x+1)
      yup = max(0, y-1)
      ydown = min(height-1, y+1)
      check_collisions(x,yup,cell_value)
      check_collisions(xleft,yup,cell_value)
      check_collisions(xleft,y,cell_value)
      check_collisions(xleft,ydown,cell_value)
      check_collisions(x,ydown,cell_value)
      check_collisions(xright,ydown,cell_value)
      check_collisions(xright,y,cell_value)
      check_collisions(xright,yup,cell_value)
    else:
      print ("Found collision",group_index,cell_value)
      cluster_results[cluster_results == group_index] = 0
      cluster_results[cluster_results == cell_value] = 0


# # check_collisions(4,2,group_index)
# # x = 4
# # y = 77
# # cell_value = cluster_results[y][x]
# # print ("cell_value",cell_value)
# # print ("visited_cells[y][x]==0",visited_cells[y][x]==0)
# # visited_cells[y][x] = True
# # print ("visited_cells[y][x]",visited_cells[y][x])
# 
# 
# 
for i in range(0,width):
  for j in range(0,height):
    result = check_collisions(i,j,0)

plt.matshow(cluster_results,vmin=0,vmax=19)
plt.show()
plt.matshow(cluster_results)
plt.show()

```

```{python}

###### Remove ROIs with SNR < cutoff for average of all control trials #####
############################################################################

plt.matshow(cluster_results)
plt.show()

pixel_sn_data = r.pixel_sn_data
SNRcutoff = r.SNRcutoff

roi_averages = numpy.zeros((width,height))

# print (len(numpy.unique(cluster_results)))
# 
# # for roi_group_index in numpy.unique(cluster_results):
# roi_group_index = numpy.unique(cluster_results)[0]
# print (roi_group_index)
# location_index = (cluster_results == roi_group_index)
# print (location_index)
# sn_data_for_group = pixel_sn_data * location_index
# print (sn_data_for_group)
# average = sn_data_for_group[sn_data_for_group != 0].mean()
# print (average)
# if average > SNRcutoff:
#   print (average)
#   # roi_averages += (cluster_results == roi_group_index) * average
# else:
#   print ("Below SNR threshold.")
# roi_averages += (cluster_results == roi_group_index) * average
# print (roi_averages)

# roi_averages[roi_averages < SNRcutoff] = 0
# r.roi_averages = roi_averages[roi_averages > SNRcutoff]
# plt.matshow(roi_averages)
# plt.show()





for roi_group_index in numpy.unique(cluster_results):
  location_index = (cluster_results == roi_group_index)
  sn_data_for_group = pixel_sn_data * location_index
  average = sn_data_for_group[sn_data_for_group != 0].mean()
  if average > SNRcutoff:
    print (average)
  else:
    print ("Below SNR threshold.")
  roi_averages += (cluster_results == roi_group_index) * average

roi_averages[roi_averages < SNRcutoff] = 0
r.roi_averages = roi_averages[roi_averages > SNRcutoff]
plt.matshow(roi_averages)
plt.show()

print (roi_averages)

```

```{python}
######################### Replot electrode #################################
############################################################################

plt.matshow(roi_averages)
plt.show()

for i in range(0,width): #add electrode as new "roi"
  for j in range(0,height):
    if electrode_data[j][i] != 0:
      # cluster_results[j][i] = electrode_data[j][i]
      roi_averages[j][i] = electrode_cluster

plt.matshow(roi_averages)
plt.show()

# print (numpy.unique(roi_averages))

# roi_average = [4.69941,5.0156]
unique_SNR = numpy.unique(roi_averages)
unique_SNR = numpy.delete(unique_SNR,0)
# print (unique_SNR)

roi_averages = numpy.transpose(roi_averages)

pixel_coords_for_all_rois = []
total_pixels_in_all_rois = 0
for roi in range(0,len(unique_SNR)):
  # roi = 2
  # print (roi)
  pixel_coords_for_roi = list(zip(*numpy.where(roi_averages == unique_SNR[roi])))
  # print (len(pixel_coords_for_roi))
  # print (pixel_coords_for_roi)
  # print (len(pixel_coords_for_roi))
  total_pixels_in_all_rois += len(pixel_coords_for_roi)
  pixel_coords_to_import = []
  for coord_pair in pixel_coords_for_roi:
    pixel_coords_to_import.extend([coord_pair,unique_SNR[roi]])
  # print (pixel_coords_to_import)
  pixel_coords_for_all_rois.extend([pixel_coords_to_import])
  # print (pixel_coords_for_all_rois)
  # print (len(pixel_coords_for_all_rois))
  # pixel_coords_for_all_rois.extend([pixel_coords_for_roi,unique_SNR[roi]])
  # pixel_coords_for_all_rois.extend([pixel_coords_for_roi])
  # pixel_coords_for_all_rois.extend([pixel_coords_for_roi,[unique_SNR[roi]]*len(pixel_coords_for_roi)])
#   print (pixel_coords_for_all_rois)
print (pixel_coords_for_all_rois)
# print (unique_SNR)
# print (total_pixels_in_all_rois)



# test = numpy.where(roi_averages == 4.69941)
# test = list(zip(*numpy.where(roi_averages == roi_average)))
# test = [list(zip(*numpy.where(roi_averages == 4.69941))),list(zip(*numpy.where(roi_averages == 5.0156)))]
# test2 = list(test)
# print (test)
# test2 = [test,roi_average]
# print(test2)

# print ([test])
### do something with list.append() here?
```

``` {R}
# test2 <- unlist(py$test2)
# pixel_coords_for_all_rois <- py$pixel_coords_for_all_rois
pixel_coords_for_all_rois <- py$pixel_coords_for_all_rois
total_pixels_in_all_rois <- py$total_pixels_in_all_rois
# test
# unlist(test)
final_rois_from_python <- matrix(unlist(pixel_coords_for_all_rois),nrow = total_pixels_in_all_rois,byrow=TRUE)
final_rois <- data.frame(matrix(ncol=5,nrow=nrow(final_rois_from_python)))
colnames(final_rois) <- c("Pixel_ID","X","Y","ROI_ID","SNR")
# final_rois$X <- final_rois_from_python[,1]+1
# final_rois$Y <- 80-(final_rois_from_python[,2]+1)
final_rois$X <- final_rois_from_python[,1]+1
final_rois$Y <- 80-(final_rois_from_python[,2])
final_rois$SNR <- final_rois_from_python[,3]


for (i in 1:nrow(final_rois)) {
  all_x <- which(myfiles_df_cl$X==final_rois$X[i])
  all_y <- which(myfiles_df_cl$Y==final_rois$Y[i])
  final_rois$Pixel_ID[i] <- intersect(all_x,all_y)
}


roi_index <- 0
for (i in 1:length(unique(final_rois$SNR))) {
  final_rois$ROI_ID[which(final_rois$SNR==unique(final_rois$SNR)[i])] <- roi_index
  roi_index <- roi_index + 1
}

nROIs <- max(final_rois$ROI_ID)+1
dat_file <- data.frame(matrix(ncol=1,nrow=3*nROIs+1+nrow(final_rois)))
colnames(dat_file) <- NULL
dat_file[1,1] <- nROIs
row_id <- 2
for (i in 0:max(final_rois$ROI_ID)) {
  dat_file[c(row_id,(row_id+2)),1] <- i
  dat_file[(row_id+1),1] <- length(which(final_rois$ROI_ID==i))+1
  dat_file[c((row_id+3):(row_id+2+length(which(final_rois$ROI_ID==i)))),1] <- (final_rois$Pixel_ID[which(final_rois$ROI_ID==i)])-1 
  row_id <- row_id+3+length(which(final_rois$ROI_ID==i))
}

write.table(dat_file,"final_rois.dat",
              # paste(min(roiindexesinthisdatfile),"to",max(roiindexesinthisdatfile),".dat",sep=""),
              row.names = FALSE)
















# np <- import("numpy", convert=FALSE)
# (x <- np$reshape(np$arange(1, 25), c(4L, 3L, 2L)))
# (x <- np$reshape(np$arange(pixel_coords_for_all_rois), c(4L, 3L, 2L)))


# test <- py_to_r(pixel_coords_for_all_rois)

# xycoords <- test2[-(length(test2))]
# roi_average <- test2[length(test2)]
# xcoords <- xycoords[seq(1,length(xycoords),2)]
# ycoords <- xycoords[seq(2,length(xycoords),2)]
# final_rois <- data.frame(matrix(ncol=5,nrow=length(xcoords)))
# colnames(final_rois) <- c("Pixel_ID","X","Y","ROI_ID","SNR")
# final_rois$X <- as.data.frame(xcoords)
# final_rois$Y <- ycoords
# final_rois$SNR <- roi_average



```















