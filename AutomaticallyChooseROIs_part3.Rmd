---
title: "AutomaticallyChooseROIs_part2.0"
output: html_document
---
```{r setup, include = FALSE}
knitr::knit_engines$set(python = reticulate::eng_python)
```

```{r}
setwd("G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/04-01")

########################## Set initial values###############################
############################################################################

k <- 3 #number of clusters chosen by hand based on silhouette plot
SNRcutoff <- 4

myslice <- "04-01"
mydate <- "07-11-2020"
dateSlice <- paste(mydate,myslice,sep=" ")

saveclusterplot <- 0 #1 = save, 0 = don't save
  clusterplotheight <- 5
  clusterplotwidth <- 6.5
saveallpotentialroisplot <- 0 #1 = save, 0 = don't save
  allroiplotheight <- 5
  allroiplotwidth <- 6.5
savepotentialroiscorrectsizeplot <- 0 #1 = save, 0 = don't save
  nonoverlaproiplotheight <- 5
  nonoverlaproiplotwidth <- 8
saveroisgoodsnrplot <- 0 #1 = save, 0 = don't save
  roiplotheight <- 5
  roiplotwidth <- 6.5
savefinalroisplot <- 0 #1 = save, 0 = don't save
  finalroiplotheight <- 5
  finalroiplotwidth <- 6.5

#################### Read in data and load libraries #######################
############################################################################

library(ggplot2)
library(dendextend)
library(plyr)
library(dplyr)
library(reshape2)
library(tidyr)
library(reticulate)

myclusterdata <- read.csv("EachPixel_Cluster.csv",check.names = FALSE)
myclustAvgGps_df_sc <- as.data.frame(myclusterdata$AvgGps)

myfiles <- read.csv("EachPixel_Data.csv",check.names = FALSE)

electrodepixels <- read.csv("electrodepixels.csv",header=FALSE)
electrodepixels <- electrodepixels+1 #photoZ starts counting with 0

############## Hierarchical clustering using chosen k ######################
############################################################################

dist_mat <- dist(myclustAvgGps_df_sc,method="euclidean")
hclust_avg <- hclust(dist_mat,method="average")
cut_avg <- cutree(hclust_avg,k=k)

avg_dend_obj <- as.dendrogram(hclust_avg)
avg_col_dend <- color_branches(avg_dend_obj,h=k)

myclusterdata_df_cl <- mutate(myclusterdata, cluster = cut_avg)

myfiles_df_cl <- data.frame(matrix(ncol=ncol(myfiles)+1,
                                   nrow=nrow(myfiles)))
colnames(myfiles_df_cl) <- c(colnames(myfiles),"Cluster")
myfiles_df_cl[,1:ncol(myfiles)] <- myfiles[,1:ncol(myfiles)]
for (i in 1:nrow(myclusterdata_df_cl)) {
  myclusterpixelid <- which(myfiles_df_cl$PixelID==myclusterdata_df_cl$PixelID[i])
  myfiles_df_cl$Cluster[myclusterpixelid] <- myclusterdata_df_cl$cluster[i]
}

clusteraverages_all <- data.frame(matrix(nrow=k,ncol=2))
colnames(clusteraverages_all) <- c("Avg","SD")
rownames(clusteraverages_all) <- paste(rep("Clust"),1:k,sep="")

clusteraverages <- data.frame(matrix(ncol=2,nrow=k))
colnames(clusteraverages) <- c("k","StN_Avg")
clusteraverages$k <- seq(1:k)
for (i in 1:k) {
  allcolmeans <- colMeans(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),])
  myclustersd <- sd(as.matrix(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),4:6]))
  clusteraverages$StN_Avg[i] <- allcolmeans[which(colnames(myfiles_df_cl)=="AvgGps")]
  clusteraverages_all$Avg[i] <- clusteraverages$StN_Avg[i]
  clusteraverages_all$SD[i] <- myclustersd
}

if (((min(which(clusteraverages$StN_Avg>SNRcutoff)))-1)>0) {
  clustercutoff <- (which(clusteraverages$StN_Avg>SNRcutoff))-1
} else {
  clustercutoff <- 0
}

######################### Plot clusters ####################################
############################################################################

ggplot(myfiles_df_cl,aes(x=X,y=Y)) +
  geom_tile(aes(fill=myfiles_df_cl$Cluster)) +
  labs(title=paste(dateSlice,"Clusters"), fill="SNR Avg +/- SD") +
  theme(
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    # axis.ticks = element_blank(),
    # axis.text = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(hjust=0.5),
    legend.position = "none"
  ) +
  guides(fill = guide_legend(keyheight = 0.9)) +
  scale_y_reverse() +
  scale_fill_gradientn(breaks=seq(1:k),
                       labels=c(paste(round(clusteraverages_all$Avg,3),"+/-",round(clusteraverages_all$SD,3))),
                       colors=rev(c("red1","yellow1","green1","dodgerblue1","navy"))
  )

# if (saveclusterplot==1) {
#   ggsave("Step2_Clusters.jpg",height=plotheight,width=plotwidth)
# }

matrixplot <- function(matrix_to_plot, ptitle) {
  longData<-melt(matrix_to_plot)
  longData<-longData[!is.na(longData$value),]
  ggplot(longData, aes(x = Var2, y = Var1)) + 
    geom_tile(aes(fill=value)) + 
    scale_fill_gradient(low="blue", high="red") +
    labs(x="x", y="y", title=ptitle) +
    scale_y_reverse() +
    theme_bw() + theme(axis.text.x=element_text(size=9, angle=0, vjust=0.3),
                       axis.text.y=element_text(size=9),
                       plot.title=element_text(size=11))
}

####################### Find all potential ROIs ############################
############################################################################
height = 80
width = 80
pixel_cluster_data <- t(matrix(myfiles_df_cl$Cluster, ncol=width, nrow=height))
pixel_cluster_data[is.na(pixel_cluster_data)] <- 0
```


```{python}
import numpy
import matplotlib.pyplot as plt
import pandas
pixel_cluster_data = r.pixel_cluster_data
width = len(pixel_cluster_data)
height = len(pixel_cluster_data[0])

cluster_results = numpy.zeros((width,height))

def combine_bound(bound1, bound2):
  if bound2 is None:
    return bound1
  if bound1 is None:
    return bound2
  result = [
    min(bound1[0],bound2[0]),
    max(bound1[1],bound2[1]),
    min(bound1[2],bound2[2]),
    max(bound1[3],bound2[3])
  ]
  return result

def check_cell(x, y, group_index, color):
  cell_value = pixel_cluster_data[y][x]
  if (cell_value != 0 and cluster_results[y][x] == 0 and (color == 0 or cell_value == color)):
    cluster_results[y][x] = group_index
    my_bound = [x,x,y,y]
    xleft = max(0, x-1)
    xright = min(width-1, x+1)
    yup = max(0, y-1)
    ydown = min(height-1, y+1)
    child_bound = check_cell(x,yup,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    child_bound = check_cell(x,ydown,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    child_bound = check_cell(xleft,y,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    child_bound = check_cell(xright,y,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    return my_bound
  else:
    return None
  
group_index = 1 #0 = never visited, 1 = first roi, 2 = second roi, etc
group_bound = []
  
for i in range(0,width):
  for j in range(0,height):
    result = check_cell(i, j, group_index, 0)
    if result is not None:
      group_index += 1
      group_bound.append(result)

#print (group_bound)
#print (len(group_bound))
plt.matshow(cluster_results)
plt.show()
r.cluster_results = cluster_results    
```
```{python}
bound_limit = 3

for i in range(0,len(group_bound)):
  group = group_bound[i]
  x_big = (group[1] - group[0]) > (bound_limit-1)
  y_big = (group[3] - group[2]) > (bound_limit-1)
  if x_big or y_big:
    print (i,group,x_big,y_big,"is out of bounds.")
    cluster_results[cluster_results == (i+1)] = 0 #0 vs 1 index mismatch ie counting from 0 here but index from 1 above

r.cluster_results = cluster_results
plt.matshow(cluster_results)
plt.show()


```

```{python}
pixel_cluster_data = pixel_cluster_data * (cluster_results > 0)

plt.matshow(pixel_cluster_data)
plt.show()
```
```{python}
visited_cells = numpy.zeros((width,height))
def check_collisions(x,y,group_index):
  cell_value = cluster_results[y][x]
  if cell_value != 0 and visited_cells[y][x] == 0:
    visited_cells[y][x] = True
    if group_index == 0 or cell_value==group_index:
      xleft = max(0, x-1)
      xright = min(width-1, x+1)
      yup = max(0, y-1)
      ydown = min(height-1, y+1)
      check_collisions(x,yup,cell_value)
      check_collisions(xleft,yup,cell_value)
      check_collisions(xleft,y,cell_value)
      check_collisions(xleft,ydown,cell_value)
      check_collisions(x,ydown,cell_value)
      check_collisions(xright,ydown,cell_value)
      check_collisions(xright,y,cell_value)
      check_collisions(xright,yup,cell_value)
    else:
      print ("Found collision",group_index,cell_value)
      cluster_results[cluster_results == group_index] = 0
      cluster_results[cluster_results == cell_value] = 0

for i in range(0,width):
  for j in range(0,height):
    result = check_collisions(i,j,0)

plt.matshow(cluster_results)
plt.show()

```
```{python}
pixel_cluster_data = pixel_cluster_data * (cluster_results > 0)

plt.matshow(pixel_cluster_data)
plt.show()
```
















