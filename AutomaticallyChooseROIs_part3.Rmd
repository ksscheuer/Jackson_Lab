
```{r setup, include = FALSE}
knitr::knit_engines$set(python = reticulate::eng_python)
# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/04-01")
# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/03-01")
# knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-11_ACC/02-01")
knitr::opts_knit$set(root.dir = "G:/My Drive/Jackson/PhotoZ_data/Step1_ROIs/2020-07-12_ACC/06-01")
```

```{r fig.width=10, fig.height=10}

########################## Set initial values###############################
############################################################################

k <- 3 #number of clusters chosen by hand based on silhouette plot
SNRcutoff <- 3
ROI_diameter_cutoff <- 3

myslice <- "03-01"
mydate <- "07-11-2020"
dateSlice <- paste(mydate,myslice,sep=" ")

## note that plots are saved in same location as this file, not working directory
saveclusterplot <- 1 #1 = save, 0 = don't save
  clusterplotheight <- 6
  clusterplotwidth <- 6
saveallpotentialroisplot <- 0 #1 = save, 0 = don't save
  allroiplotheight <- 5
  allroiplotwidth <- 6.5
savepotentialroiscorrectsizeplot <- 0 #1 = save, 0 = don't save
  nonoverlaproiplotheight <- 5
  nonoverlaproiplotwidth <- 8
saveroisgoodsnrplot <- 0 #1 = save, 0 = don't save
  roiplotheight <- 5
  roiplotwidth <- 6.5
savefinalroisplot <- 0 #1 = save, 0 = don't save
  finalroiplotheight <- 5
  finalroiplotwidth <- 6.5

  
#################### Read in data and load libraries #######################
############################################################################

library(ggplot2)
library(dendextend)
library(plyr)
library(dplyr)
library(reshape2)
library(tidyr)
library(reticulate)

myclusterdata <- read.csv("EachPixel_Cluster.csv",check.names = FALSE)
myclustAvgGps_df_sc <- as.data.frame(myclusterdata$AvgGps)

myfiles <- read.csv("EachPixel_Data.csv",check.names = FALSE)

electrodepixels <- read.csv("electrodepixels.csv",header=FALSE)
electrodepixels <- electrodepixels+1 #photoZ starts counting with 0


############## Hierarchical clustering using chosen k ######################
############################################################################

dist_mat <- dist(myclustAvgGps_df_sc,method="euclidean")
hclust_avg <- hclust(dist_mat,method="average")
cut_avg <- cutree(hclust_avg,k=k)

avg_dend_obj <- as.dendrogram(hclust_avg)
avg_col_dend <- color_branches(avg_dend_obj,h=k)

myclusterdata_df_cl <- mutate(myclusterdata, cluster = cut_avg)

myfiles_df_cl <- data.frame(matrix(ncol=ncol(myfiles)+1,
                                   nrow=nrow(myfiles)))
colnames(myfiles_df_cl) <- c(colnames(myfiles),"Cluster")
myfiles_df_cl[,1:ncol(myfiles)] <- myfiles[,1:ncol(myfiles)]
for (i in 1:nrow(myclusterdata_df_cl)) {
  myclusterpixelid <- which(myfiles_df_cl$PixelID==myclusterdata_df_cl$PixelID[i])
  myfiles_df_cl$Cluster[myclusterpixelid] <- myclusterdata_df_cl$cluster[i]
}

clusteraverages_all <- data.frame(matrix(nrow=k,ncol=2))
colnames(clusteraverages_all) <- c("Avg","SD")
rownames(clusteraverages_all) <- paste(rep("Clust"),1:k,sep="")

clusteraverages <- data.frame(matrix(ncol=2,nrow=k))
colnames(clusteraverages) <- c("k","StN_Avg")
clusteraverages$k <- seq(1:k)
for (i in 1:k) {
  allcolmeans <- colMeans(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),])
  myclustersd <- sd(as.matrix(myfiles_df_cl[which(myfiles_df_cl$Cluster==i),4:6]))
  clusteraverages$StN_Avg[i] <- allcolmeans[which(colnames(myfiles_df_cl)=="AvgGps")]
  clusteraverages_all$Avg[i] <- clusteraverages$StN_Avg[i]
  clusteraverages_all$SD[i] <- myclustersd
}

if (((min(which(clusteraverages$StN_Avg>SNRcutoff)))-1)>0) {
  clustercutoff <- (which(clusteraverages$StN_Avg>SNRcutoff))-1
} else {
  clustercutoff <- 0
}


######################### Plot clusters ####################################
############################################################################

ggplot(myfiles_df_cl,aes(x=X,y=Y)) +
  geom_tile(aes(fill=myfiles_df_cl$Cluster),color="gray") +
  labs(title=paste(dateSlice,"Clusters"), fill="SNR Avg +/- SD") +
  theme(
    axis.title.y = element_blank(),
    axis.title.x = element_blank(),
    # axis.ticks = element_blank(),
    # axis.text = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(hjust=0.5),
    legend.position = "none"
  ) +
  guides(fill = guide_legend(keyheight = 0.9)) +
  scale_y_reverse() +
  scale_fill_gradientn(breaks=seq(1:k),
                       labels=c(paste(round(clusteraverages_all$Avg,3),"+/-",round(clusteraverages_all$SD,3))),
                       colors=rev(c("red1","yellow1","green1","dodgerblue1","navy"))
  )

if (saveclusterplot==1) {
  ggsave("clusterplot.jpg",height=clusterplotheight,width=clusterplotwidth)
}

# matrixplot <- function(matrix_to_plot, ptitle) {
#   longData<-melt(matrix_to_plot)
#   longData<-longData[!is.na(longData$value),]
#   ggplot(longData, aes(x = Var2, y = Var1)) + 
#     geom_tile(aes(fill=value)) + 
#     scale_fill_gradient(low="blue", high="red") +
#     labs(x="x", y="y", title=ptitle) +
#     scale_y_reverse() +
#     theme_bw() + theme(axis.text.x=element_text(size=9, angle=0, vjust=0.3),
#                        axis.text.y=element_text(size=9),
#                        plot.title=element_text(size=11))
# }


############ Convert data to height x width representation #################
############################################################################
height = 80
width = 80
pixel_cluster_data <- t(matrix(myfiles_df_cl$Cluster, ncol=width, nrow=height))
# pixel_cluster_data <- matrix(myfiles_df_cl$Cluster, ncol=width, nrow=height)
pixel_cluster_data[is.na(pixel_cluster_data)] <- 0
pixel_sn_data <- t(matrix(myfiles_df_cl$Avg, ncol=width, nrow=height))
myfiles_df_cl_with_electrode <- mutate(myfiles_df_cl,Electrode = 0)
for (i in 1:nrow(electrodepixels)) {
  myfiles_df_cl_with_electrode$Electrode[which(myfiles_df_cl_with_electrode$PixelID==electrodepixels[i,1])] <- 1
}
electrode_data <- t(matrix(myfiles_df_cl_with_electrode$Electrode, ncol=width, nrow=height))

electrode_x_min <- min(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_x <- max(myfiles_df_cl_with_electrode$X[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_min <- min(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_y_max <- max(myfiles_df_cl_with_electrode$Y[which(myfiles_df_cl_with_electrode$Electrode==1)])
electrode_tip_y <- (electrode_y_min + electrode_y_max) / 2

```


```{python}

############ Identify each potential ROI and bounds for each ROI ###########
############################################################################

import numpy
import matplotlib.pyplot as plt
import pandas
pixel_cluster_data = r.pixel_cluster_data
width = len(pixel_cluster_data)
height = len(pixel_cluster_data[0])

plt.matshow(pixel_cluster_data)
plt.show()

cluster_results = numpy.zeros((width,height))

def combine_bound(bound1, bound2):
  if bound2 is None:
    return bound1
  if bound1 is None:
    return bound2
  result = [
    min(bound1[0],bound2[0]),
    max(bound1[1],bound2[1]),
    min(bound1[2],bound2[2]),
    max(bound1[3],bound2[3])
  ]
  return result

def check_cell(x, y, group_index, color):
  cell_value = pixel_cluster_data[y][x]
  if (cell_value != 0 and cluster_results[y][x] == 0 and (color == 0 or cell_value == color)):
    cluster_results[y][x] = group_index
    my_bound = [x,x,y,y]
    xleft = max(0, x-1)
    xright = min(width-1, x+1)
    yup = max(0, y-1)
    ydown = min(height-1, y+1)
    child_bound = check_cell(x,ydown,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    child_bound = check_cell(x,yup,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    child_bound = check_cell(xright,y,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    child_bound = check_cell(xleft,y,group_index,cell_value)
    my_bound = combine_bound(my_bound,child_bound)
    return my_bound
  else:
    return None
  
group_index = 1 #0 = never visited, 1 = first roi, 2 = second roi, etc
group_bound = []
  
# check_cell(0,53,group_index,0)  

for i in range(0,width):
  for j in range(0,height):
    result = check_cell(i, j, group_index, 0)
    if result is not None:
      group_index += 1
      group_bound.append(result)

#print (group_bound)
#print (len(group_bound))
plt.matshow(cluster_results)
plt.show()
r.cluster_results = cluster_results   
```

```{python}

############# Remove ROIs with diameter greater than cutoff ################
############################################################################

bound_limit = r.ROI_diameter_cutoff
# bound_limit = 3

for i in range(0,len(group_bound)):
  group = group_bound[i]
  x_big = (group[1] - group[0]) > (bound_limit-1)
  y_big = (group[3] - group[2]) > (bound_limit-1)
  if x_big or y_big:
    print (i,group,x_big,y_big,"is out of bounds.")
    cluster_results[cluster_results == (i+1)] = 0 #0 vs 1 index mismatch ie counting from 0 here but index from 1 above

r.cluster_results = cluster_results
plt.matshow(cluster_results)
plt.show()


```
```{python}

################ Separate remaining ROIs based on cluster ##################
############################################################################

pixel_cluster_data = pixel_cluster_data * (cluster_results > 0)

plt.matshow(pixel_cluster_data)
plt.show()
```

```{python}
############################ Add electrode #################################
############################################################################

electrode_data = r.electrode_data #1 if pixel in electrode, 0 if not
# print (electrode_data)

electrode_data = electrode_data * (max(numpy.unique(cluster_results))+1) #0 if not in electrode, 1+max group number if in cluster
# print (electrode_data)

plt.matshow(pixel_cluster_data)
plt.show()

electrode_cluster = max(numpy.unique(pixel_cluster_data))+1

for i in range(0,width): #add electrode as new "roi"
  for j in range(0,height):
    if electrode_data[j][i] != 0:
      cluster_results[j][i] = electrode_data[j][i]
      pixel_cluster_data[j][i] = electrode_cluster

plt.matshow(pixel_cluster_data)
plt.show()

```

```{python}

##################### Remove ROIs that are touching ########################
############################################################################

plt.matshow(cluster_results)
plt.show()

plt.matshow(pixel_cluster_data)
plt.show()

visited_cells = numpy.zeros((width,height))
def check_collisions(x,y,group_index):
  cell_value = cluster_results[y][x]
  if cell_value != 0 and visited_cells[y][x] == 0:
    visited_cells[y][x] = True
    if group_index == 0 or cell_value==group_index:
      xleft = max(0, x-1)
      xright = min(width-1, x+1)
      yup = max(0, y-1)
      ydown = min(height-1, y+1)
      check_collisions(x,yup,cell_value)
      check_collisions(xleft,yup,cell_value)
      check_collisions(xleft,y,cell_value)
      check_collisions(xleft,ydown,cell_value)
      check_collisions(x,ydown,cell_value)
      check_collisions(xright,ydown,cell_value)
      check_collisions(xright,y,cell_value)
      check_collisions(xright,yup,cell_value)
    else:
      print ("Found collision",group_index,cell_value)
      cluster_results[cluster_results == group_index] = 0
      cluster_results[cluster_results == cell_value] = 0

for i in range(0,width):
  for j in range(0,height):
    result = check_collisions(i,j,0)

plt.matshow(cluster_results)
plt.show()

```

```{python}

###### Remove ROIs with SNR < cutoff for average of all control trials #####
############################################################################

plt.matshow(cluster_results)
plt.show()

pixel_sn_data = r.pixel_sn_data
SNRcutoff = r.SNRcutoff

roi_averages = numpy.zeros((width,height))

# print (len(numpy.unique(cluster_results)))
# 
# # for roi_group_index in numpy.unique(cluster_results):
# roi_group_index = numpy.unique(cluster_results)[0]
# print (roi_group_index)
# location_index = (cluster_results == roi_group_index)
# print (location_index)
# sn_data_for_group = pixel_sn_data * location_index
# print (sn_data_for_group)
# average = sn_data_for_group[sn_data_for_group != 0].mean()
# print (average)
# if average > SNRcutoff:
#   print (average)
#   # roi_averages += (cluster_results == roi_group_index) * average
# else:
#   print ("Below SNR threshold.")
# roi_averages += (cluster_results == roi_group_index) * average
# print (roi_averages)

# roi_averages[roi_averages < SNRcutoff] = 0
# r.roi_averages = roi_averages[roi_averages > SNRcutoff]
# plt.matshow(roi_averages)
# plt.show()





for roi_group_index in numpy.unique(cluster_results):
  location_index = (cluster_results == roi_group_index)
  sn_data_for_group = pixel_sn_data * location_index
  average = sn_data_for_group[sn_data_for_group != 0].mean()
  if average > SNRcutoff:
    print (average)
  else:
    print ("Below SNR threshold.")
  roi_averages += (cluster_results == roi_group_index) * average

roi_averages[roi_averages < SNRcutoff] = 0
r.roi_averages = roi_averages[roi_averages > SNRcutoff]
plt.matshow(roi_averages)
plt.show()

print (roi_averages)

```

```{python}
######################### Replot electrode #################################
############################################################################

plt.matshow(roi_averages)
plt.show()

for i in range(0,width): #add electrode as new "roi"
  for j in range(0,height):
    if electrode_data[j][i] != 0:
      # cluster_results[j][i] = electrode_data[j][i]
      roi_averages[j][i] = electrode_cluster

plt.matshow(roi_averages)
plt.show()

```















